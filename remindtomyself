1.比如我们经常要用的是否被2整除，一般都写成  if(n % 2 == 0)
可以换成 if((n&1) == 0)
2.| 比较实用的例子
可以用一个unsigned int 来存储多个布尔值。比如一个文件有读权限，写权限，执行权限。看起来要记录3个布尔值。我们可以用一个unsigned int也可以完成任务。

 

一个数r来表示读权限，它只更改个位来记录读权限的布尔值

00000001  (表示有读权限)

00000000  (表示没有读权限)

 

一个数w表示写权限，它只用二进制的倒数第二位来记录布尔值

00000010 (表示有写权限)

00000000 (表示没有写权限)

 

一个数x表示执行权限，它只用倒数第三位来记录布尔值

00000100 (表示有执行权限)

00000000 (表示没有执行权限)

 

那么一个文件同时没有3种权限就是

~r | ~ w | ~ x 即为 00000000，就是0

 

只有读的权限就是

r | ~w | ~x 即为 00000001，就是1

只有写的权限就是

~r | w | ~x 即为 00000010，就是2

…

一个文件同时有3种权限就是

r | w | x 即为 00000111，就是7



3.比如 int t = {1,2,3,3,2,1,5} 要找到5。

用异或就完美了，所有相同的都会消失，留下来的就是5了。我发现异或是嫉妒成双成对的。

int singleNumber(int A[], int n) {
for(int i = 1; i < n; ++i){
A[0] ^= A[i];
}
return A[0];
}
还有就是用不tmp值来交换两个数

//不用temp交换两个整数
void swap(int& x , int& y)
{
x ^= y;
y ^= x;
x ^= y;
}



4.lower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找的。

在从小到大的排序数组中，

lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。

upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。


